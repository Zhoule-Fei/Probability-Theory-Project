<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Central Limit Theorem Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .control-group input[type="range"] {
            padding: 0;
        }
        
        button {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
        }
        
        .chart-container h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart-container p {
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #2196f3;
        }
        
        .info-box h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }
        
        .info-box ul {
            list-style-position: inside;
            color: #555;
            line-height: 1.8;
        }
        
        @media (max-width: 768px) {
            .charts {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Central Limit Theorem Simulator</h1>
        <p class="subtitle">Watch how sample means form a normal distribution, regardless of the population distribution!</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="distribution">Population Distribution</label>
                <select id="distribution">
                    <option value="uniform">Uniform</option>
                    <option value="exponential">Exponential</option>
                    <option value="bimodal">Bimodal</option>
                    <option value="chisquare">Chi-Square (df=3)</option>
                    <option value="beta">Beta (α=2, β=5)</option>
                    <option value="gamma">Gamma (shape=2, scale=2)</option>
                    <option value="lognormal">Log-Normal (μ=0, σ=0.5)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="sampleSize">Sample Size: <span id="sampleSizeValue">30</span></label>
                <input type="range" id="sampleSize" min="5" max="100" value="30">
            </div>
            
            <div class="control-group">
                <label for="numSamples">Number of Samples: <span id="numSamplesValue">1000</span></label>
                <input type="range" id="numSamples" min="100" max="20000" step="100" value="1000">
            </div>
            
            <button id="runBtn">Run Simulation</button>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <h3>Population Distribution</h3>
                <canvas id="populationChart"></canvas>
                <p>This is the original population distribution (non-normal)</p>
            </div>
            
            <div class="chart-container">
                <h3>Distribution of Sample Means</h3>
                <canvas id="samplingChart"></canvas>
                <p>Notice how this approaches a normal (bell-shaped) distribution!</p>
            </div>
        </div>
        
        <div class="info-box">
            <h3>What's Happening?</h3>
            <ul>
                <li>The CLT states that when you take many samples from any distribution and calculate their means, those means will form a normal distribution</li>
                <li>This works even if the original population distribution is not normal</li>
                <li>Larger sample sizes make the distribution of means more normal</li>
                <li>Try different distributions and sample sizes to see the effect!</li>
            </ul>
        </div>
    </div>

    <script>
        let populationChart, samplingChart;
        
        // Get elements
        const distributionSelect = document.getElementById('distribution');
        const sampleSizeInput = document.getElementById('sampleSize');
        const numSamplesInput = document.getElementById('numSamples');
        const sampleSizeValue = document.getElementById('sampleSizeValue');
        const numSamplesValue = document.getElementById('numSamplesValue');
        const runBtn = document.getElementById('runBtn');
        
        // Update value displays
        sampleSizeInput.addEventListener('input', (e) => {
            sampleSizeValue.textContent = e.target.value;
        });
        
        numSamplesInput.addEventListener('input', (e) => {
            numSamplesValue.textContent = e.target.value;
        });
        
        // Helper function: Generate standard normal random variable (Box-Muller transform)
        function randn() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }
        
        // Helper function: Gamma function approximation (Stirling's approximation)
        function gammaFunction(z) {
            if (z < 0.5) {
                return Math.PI / (Math.sin(Math.PI * z) * gammaFunction(1 - z));
            }
            z -= 1;
            const g = 7;
            const coef = [
                0.99999999999980993,
                676.5203681218851,
                -1259.1392167224028,
                771.32342877765313,
                -176.61502916214059,
                12.507343278686905,
                -0.13857109526572012,
                9.9843695780195716e-6,
                1.5056327351493116e-7
            ];
            
            let x = coef[0];
            for (let i = 1; i < g + 2; i++) {
                x += coef[i] / (z + i);
            }
            
            const t = z + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }
        
        // Helper function: Beta function
        function betaFunction(a, b) {
            return gammaFunction(a) * gammaFunction(b) / gammaFunction(a + b);
        }
        
        // Generate population data for visualization
        function generatePopulation(dist) {
            const data = [];
            const bins = 100;
            
            if (dist === 'uniform') {
                for (let i = 0; i < bins; i++) {
                    data.push({ x: i / bins, y: 1 });
                }
            } else if (dist === 'exponential') {
                for (let i = 0; i < bins; i++) {
                    const x = i / bins * 5;
                    data.push({ x: x, y: Math.exp(-x) });
                }
            } else if (dist === 'bimodal') {
                for (let i = 0; i < bins; i++) {
                    const x = (i / bins) * 10 - 5;
                    const y = 0.5 * Math.exp(-((x + 2) ** 2) / 2) + 0.5 * Math.exp(-((x - 2) ** 2) / 2);
                    data.push({ x: i / bins, y: y });
                }
            } else if (dist === 'chisquare') {
                const df = 3;
                for (let i = 0; i < bins; i++) {
                    const x = i / bins * 15;
                    if (x > 0) {
                        const y = Math.pow(x, df/2 - 1) * Math.exp(-x/2) / 
                                 (Math.pow(2, df/2) * gammaFunction(df/2));
                        data.push({ x: x, y: y });
                    } else {
                        data.push({ x: x, y: 0 });
                    }
                }
            } else if (dist === 'beta') {
                const alpha = 2, beta = 5;
                for (let i = 0; i < bins; i++) {
                    const x = i / bins;
                    if (x > 0 && x < 1) {
                        const y = Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / 
                                 betaFunction(alpha, beta);
                        data.push({ x: x, y: y });
                    } else {
                        data.push({ x: x, y: 0 });
                    }
                }
            } else if (dist === 'gamma') {
                const shape = 2, scale = 2;
                for (let i = 0; i < bins; i++) {
                    const x = i / bins * 20;
                    if (x > 0) {
                        const y = Math.pow(x, shape - 1) * Math.exp(-x/scale) / 
                                 (Math.pow(scale, shape) * gammaFunction(shape));
                        data.push({ x: x, y: y });
                    } else {
                        data.push({ x: x, y: 0 });
                    }
                }
            } else if (dist === 'lognormal') {
                const mu = 0, sigma = 0.5;
                for (let i = 0; i < bins; i++) {
                    const x = i / bins * 5 + 0.01;
                    const y = (1 / (x * sigma * Math.sqrt(2 * Math.PI))) * 
                             Math.exp(-Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));
                    data.push({ x: x, y: y });
                }
            }
            
            return data;
        }
        
        // Generate sample from distribution
        function generateSample(dist, size) {
            const samples = [];
            
            for (let i = 0; i < size; i++) {
                let value;
                
                if (dist === 'uniform') {
                    value = Math.random();
                } else if (dist === 'exponential') {
                    value = -Math.log(Math.random());
                } else if (dist === 'bimodal') {
                    if (Math.random() < 0.5) {
                        value = (Math.random() + Math.random() + Math.random() + Math.random()) / 4 * 2 - 0.5;
                    } else {
                        value = (Math.random() + Math.random() + Math.random() + Math.random()) / 4 * 2 + 0.5;
                    }
                } else if (dist === 'chisquare') {
                    // Chi-square with df=3: sum of 3 squared standard normals
                    const df = 3;
                    value = 0;
                    for (let j = 0; j < df; j++) {
                        const z = randn();
                        value += z * z;
                    }
                } else if (dist === 'beta') {
                    // Beta distribution using rejection sampling (simple method)
                    const alpha = 2, beta = 5;
                    let x, y;
                    do {
                        x = Math.random();
                        y = Math.random() * 2.5; // Max value of PDF
                        const pdf = Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / 
                                   betaFunction(alpha, beta);
                        if (y <= pdf) break;
                    } while (true);
                    value = x;
                } else if (dist === 'gamma') {
                    // Gamma distribution (shape=2, scale=2) using acceptance-rejection
                    const shape = 2, scale = 2;
                    if (shape >= 1) {
                        const d = shape - 1/3;
                        const c = 1 / Math.sqrt(9 * d);
                        while (true) {
                            let x, v;
                            do {
                                x = randn();
                                v = 1 + c * x;
                            } while (v <= 0);
                            
                            v = v * v * v;
                            const u = Math.random();
                            if (u < 1 - 0.0331 * x * x * x * x) {
                                value = d * v * scale;
                                break;
                            }
                            if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {
                                value = d * v * scale;
                                break;
                            }
                        }
                    }
                } else if (dist === 'lognormal') {
                    // Log-normal: exp(N(mu, sigma^2))
                    const mu = 0, sigma = 0.5;
                    value = Math.exp(mu + sigma * randn());
                }
                
                samples.push(value);
            }
            
            return samples;
        }
        
        // Initialize charts
        function initCharts() {
            const popCtx = document.getElementById('populationChart').getContext('2d');
            const sampCtx = document.getElementById('samplingChart').getContext('2d');
            
            populationChart = new Chart(popCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Density',
                        data: [],
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Value' } },
                        y: { title: { display: true, text: 'Density' } }
                    }
                }
            });
            
            samplingChart = new Chart(sampCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Frequency',
                        data: [],
                        backgroundColor: '#3b82f6',
                        borderColor: '#2563eb',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Sample Mean' } },
                        y: { title: { display: true, text: 'Density' } }
                    }
                }
            });
        }
        
        // Update population chart
        function updatePopulationChart(dist) {
            const data = generatePopulation(dist);
            populationChart.data.labels = data.map(d => d.x.toFixed(2));
            populationChart.data.datasets[0].data = data.map(d => d.y);
            populationChart.update();
        }
        
        // Run simulation
        function runSimulation() {
            runBtn.disabled = true;
            runBtn.textContent = 'Running Simulation...';
            
            setTimeout(() => {
                const dist = distributionSelect.value;
                const sampleSize = parseInt(sampleSizeInput.value);
                const numSamples = parseInt(numSamplesInput.value);
                
                const sampleMeans = [];
                
                for (let i = 0; i < numSamples; i++) {
                    const sample = generateSample(dist, sampleSize);
                    const mean = sample.reduce((a, b) => a + b, 0) / sample.length;
                    sampleMeans.push(mean);
                }
                
                const bins = 50;
                const minMean = Math.min(...sampleMeans);
                const maxMean = Math.max(...sampleMeans);
                const binWidth = (maxMean - minMean) / bins;
                
                const histogram = new Array(bins).fill(0);
                sampleMeans.forEach(mean => {
                    const binIndex = Math.min(Math.floor((mean - minMean) / binWidth), bins - 1);
                    histogram[binIndex]++;
                });
                
                const labels = [];
                const frequencies = [];
                
                for (let i = 0; i < bins; i++) {
                    labels.push((minMean + (i + 0.5) * binWidth).toFixed(3));
                    frequencies.push(histogram[i] / numSamples / binWidth);
                }
                
                samplingChart.data.labels = labels;
                samplingChart.data.datasets[0].data = frequencies;
                samplingChart.update();
                
                runBtn.disabled = false;
                runBtn.textContent = 'Run Simulation';
            }, 100);
        }
        
        // Event listeners
        distributionSelect.addEventListener('change', () => {
            updatePopulationChart(distributionSelect.value);
            runSimulation();
        });
        
        runBtn.addEventListener('click', runSimulation);
        
        // Initialize
        initCharts();
        updatePopulationChart('uniform');
        runSimulation();
    </script>
</body>
</html>